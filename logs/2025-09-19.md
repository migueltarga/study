# 2025-09-19

## Task
Day 1: From Scratch - Binary, hex, signed/unsigned. Convert numbers manually.


### Bases & Digits
- Binary (base 2): 0, 1
- Decimal (base 10) 0-9
- Hex (base 16): 0-9, A-F
  
### Sizes
- 1 nibble = 4 bits
- 1 byte = 8 bits

### Powers of two

|**n**|**2^n**|
|:---:|:---:|
| 0 | 1 |
| 1 | 2 |
| 2 | 4 |
| 3 | 8 |
| 4 | 16 |
| 5 | 32 |
| 6 | 64 |
| 7 | 128 |
| 8 | 256 |
| 9 | 512 |
| 10 | 1024 |


### Hex Nibble Map

|**Hex**|**Binary**|
|:---:|:---:|
| 0 | 0000 |
| 1 | 0001 |
| 2 | 0010 |
| 3 | 0011 |
| 4 | 0100 |
| 5 | 0101 |
| 6 | 0110 |
| 7 | 0111 |
| 8 | 1000 |
| 9 | 1001 |
| A | 1010 |
| B | 1011 |
| C | 1100 |
| D | 1101 |
| E | 1110 |
| F | 1111 |



## Notes
- Why power of 2 is important in computing?
  - Each bit represents a power of 2, because it uses binary (2 options) 
  - 8 bits = 2^8 = 256 values
  - Memory addresses and offsets are calculated using powers of 2
  - Bitwise operations: Shifting bits left/right multiplies/divides by powers of 2
  - In other words, every binary can only have 2 options, but every time you add another bit, you increase possibilities by ^2
- How binary represents data?
  - Hex is base 16, so each digit can show 16 values (0-15).
  - Binary is base 2, and 4 bits can also show 16 values (2⁴ = 16).
  - So, every hex digit is a shortcut for 4 binary digits.
- Unsigned vs Signed
  - Unsigned (Positive numbers) ranges from 0 to 255
  - 8-bit = 11111111 = 128+64+32+16+8+4+2+1 = 255
  - Signed (Positive and Negative) ranges from -128 to 127
  - If leftmost bit is 0: read it normally
  - If leftmost bit is 1: take unsigned value and subtract 256
    - 00000001 -> 1 (same as unsigned)
    - 10000000 -> 128−256 = −128
    - 11111111 -> 255−256 = −1
    - 11110100 -> 244−256 = −12
  - the number can wrap around 255+1 = 1 (unsigned)
  - Signed: 127+1 = −128
  - How to make a negative number
    - Start with the positive in bits
    - Flip every bit (0->1, 1->0)
    - Add 1
    - Example: +5 = 00000101
      - Flip -> 11111010
      - Add 1 -> 11111011 = −5
- Carry Flag (CF) and Overflow Flag (OF)
  - CF: Carry out on add, borrow on sub
  - OF: Wrong sign on add
  - Examples (8-bit):
    - 0xED + 0x3B = 0x28, CF=1, OF=0
    - 0x7F + 0x01 = 0x80, CF=0, OF=1
    - 0x00 - 0x01 = 0xFF, CF=1, OF=0


## Examples

- 173 (dec) to hex
  - Divide by 16: 173 / 16 = 10 remainder 13
  - In hex, 10 = A, 13 = D
  - 0xAD
- 0xAD to Binary
  - A = 1010, D = 1101
  - Join: 10101101
- 0x3A7 to binary
  - hex digits length * 4 = binary length
  - 3 = 0011, A = 1010, 7 = 0111
  - 001110100111 
- 0x3A7 to decimal
  - Hex is Base 16
  - 16^0=1, 16^1=16, 16^2=256
  - from right to left:
    - Position 2 (256): digit 3 -> 3 * 256 = 768
    - Position 1 (16): digit A=10 -> 10 * 16 = 160
    - Position 0 (1): digit 7 -> 7 * 1 = 7  
  - 768 + 160 + 7 = 935
- 173 (dec) to binary
  - Divide by 2 repeatedly, collect remainders, reverse them.
  - 173 / 2 = 86 remainder 1
  - 86 / 2 = 43 remainder 0
  - 43 / 2 = 21 remainder 1
  - 21 / 2 = 10 remainder 1
  - 10 / 2 = 5 remainder 0
  - 5 / 2 = 2 remainder 1
  - 2 / 2 = 1 remainder 0
  - 1 / 2 = 0 remainder 1
  - Reverse remainders: 10101101
- -18 to 8-bit two's complement
  - +18: 00010010
  - Flip: 11101101
  - Add 1: 11101110
- 0x5C + 0x36 (8-bit add)
  - Binary: 01011100 + 00110110 = 10010010 (0x92)
  - CF=0, OF=0
- 0xF0 + 0xF0 (8-bit add)
  - Binary: 11110000 + 11110000 = 1 11100000 (carry 1, result 0xE0)
  - CF=1, OF=1

